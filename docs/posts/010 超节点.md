---
title: 什么是超节点
date: 2025-10-01
tags:
  - 超节点
  - 系统架构
  - 硬件互联
  - NVLink
  - NVSwitch
  - NVIDIA
  - 分布式训练
  - MoE
categories:
  - AI基础设施
  - 分布式训练
slug: superpod
description: >-
  本文系统性地解构了“超节点”这一面向大规模AI计算的新一代系统架构。文章从其核心定义出发，追溯了NVIDIA从Hopper到Blackwell的超节点产品演进与技术趋势。内容深入硬件底层，详细剖析了从Die到Cluster的多层级互联体系，并对SerDes、OIF-CEI、交换芯片等关键互联技术进行了梳理。同时，文章也探讨了软件生态的演进（如NvSHMEM与PGAS）以及超节点对MoE等应用范式带来的革命性影响，为理解现代AI算力集群的构建原理提供了全面的技术指南。
---

## 什么是超节点

超节点是借助高速无损互联技术，突破传统计算节点以CPU和PCIe总线为核心的通信边界，所构建的新一代计算架构。**在硬件互联层面**，超节点采用 NVLink、CXL 或专用交换网络等先进互连协议，在加速卡（GPU/NPU）之间构建高带宽、低延迟的直接通信域（Scale-Up Domain，或称高带宽域，High Bandwidth Domain, HBD）。这种设计实现了计算单元间的大规模高效互连，从根本上缓解了传统架构中因 GPU 间通信必须经由 CPU 与 PCIe 总线而形成的性能瓶颈，为海量数据并行处理奠定了物理基础。**在软件与系统层面**，其资源管理范式也发生了转变：硬件间的高速通信通常直接绕过（bypass）操作系统内核繁复的协议栈，转而通过用户态集合通信库（如 NCCL、HCCL）进行调度，从而显著降低通信开销。

### NVIDIA超节点产品

2020年，NVIDIA在其推出的HGX-A100系统中，通过第二代NVSwitch将两个八卡A100以背板方式连接，构成一个16卡系统。2022年，随Hopper架构推出的第三代NVSwitch支持更灵活的组网方式，能够实现32颗GH200（32x GPU）的互联（NVL32）[^gh200]，最大可实现256颗GH100的互联（NVL256）。2024年Blackwell发布时，第四代NVSwitch能够实现36个GB200超级芯片（共72颗GPU）的互联（NVL72）[^gb200]，最大支持288个GB200超级芯片（共576颗GPU）的互联。未来的Vera Rubin系列将进一步实现144个超级芯片的互联。以下是Hopper与Blackwell两代GPU所对应的超节点产品：

|              参数 |          NVL32          |      GH200 SuperPod       |          NVL72           |     GB200 SuperPod      |
|------------------:|:-----------------------:|:-------------------------:|:------------------------:|:-----------------------:|
|          **架构** |         Hopper          |          Hopper           |        Blackwell         |        Blackwell        |
|      **HBM 大小** |   32 x 144GB = 4.6 TB   |   256 x 96GB = 24.5 TB    |   36 x 384GB = 13.8 TB   |  288 x 384GB = 110 TB   |
|  **LPDDR5X 大小** |  32 x 480GB = 15.4 TB   |   256 x 480GB = 123 TB    |   36 x 480GB = 17.3 TB   |  288 x 480GB = 138 TB   |
|      **HBM 带宽** |        3.35 TB/s        |         4.8 TB/s          |          8 TB/s          |         8 TB/s          |
|  **FP16 (FLOPS)** |      32 PetaFLOPS       |       256 PetaFLOPS       |      180 PetaFLOPS       |     1440 PetaFLOPS      |
|    **INT8 (OPS)** |       64 PetaOPS        |        64 PetaOPS         |       360 PetaOPS        |      2880 PetaOPS       |
|   **FP8 (FLOPS)** |      64 PetaFLOPS       |       64 PetaFLOPS        |      360 PetaFLOPS       |     2880 PetaFLOPS      |
|   **FP6 (FLOPS)** |           N/A           |            N/A            |      360 PetaFLOPS       |     2880 PetaFLOPS      |
|   **FP4 (FLOPS)** |           N/A           |            N/A            |      720 PetaFLOPS       |     5760 PetaFLOPS      |
|  **GPU-GPU 带宽** |        0.9 TB/s         |         0.9 TB/s          |         1.8 TB/s         |        1.8 TB/s         |
|      **NVSwitch** |      Gen3 64 Port       |       Gen3 64 Port        |       Gen4 72 Port       |      Gen4 72 Port       |
|   **NVLink 带宽** | 36 x 0.9 TB/s = 32 TB/s | 256 x 0.9 TB/s = 230 TB/s | 72 x 1.8 TB/s = 130 TB/s | 576 x 1.8 TB/s = 1 PB/s |
| **Ethernet 带宽** |      16 x 200 Gb/s      |      256 x 200 Gb/s       |      18 x 400 Gb/s       |     576 x 400 Gb/s      |
|       **IB 带宽** |      32 x 400 Gb/s      |      256 x 400 Gb/s       |      72 x 800 Gb/s       |     576 x 800 Gb/s      |
|    **GPUs Power** |    32 x 1 kW = 32 kW    |    256 x 1 kW = 256 kW    |  36 x 2.7 kW = 97.2 kW   |      Not provided       |

### 超节点技术趋势分析

回顾从 Volta 到 Rubin 系列的演进，NVIDIA 的技术战略非常清晰：**通过算力、互联、存储和封装等多个维度的协同创新，实现系统层面的指数级性能增长。** 其目标是每两年提供约 6 倍的系统算力提升，并计划在十年内实现 7000 倍的增长。这种复合式增长并非依赖单一技术突破，而是通过一套精心设计的“组合策略”实现：
*   **单芯片算力**：每代提升约 3 倍。
*   **Scale-Up 域**：互联规模和带宽同步翻倍。
*   **内存系统**：HBM 带宽翻倍，容量提升 3 倍。

从 Blackwell 架构开始，**先进封装** 成为其算力增长的又一关键。通过 NV-HBI（NVIDIA High-Bandwidth Interface）技术[^nvhbi]，NVIDIA 将两颗 GPU 裸片（Die）高速互联，提供高达 10 TB/s 的双向带宽，使它们在逻辑上可作为单一、统一的 GPU 工作。这标志着 NVIDIA 的增长引擎已从单纯提升单点指标（如芯片算力或互联速率），全面转向以系统为单位的整体工程优化，从而确保稳定且可预测的性能飞跃。


| 系列           | Volta               | Ampere                 | Hopper                | Blackwell            | Rubin            |
|----------------|---------------------|------------------------|-----------------------|----------------------|------------------|
| SKU            | V100                | A100(HGX)              | GH200(CPU+GPU)        | GB200(CPU+2GPU)      | ?VR200(CPU+2GPU) |
| 单卡算力（FP16） | 0.125 PFLOPS        | 0.312 PFLOPS           | 0.9 PFLOPS            | 2.25 PFLOPS x 2      |                  |
| 系统规模       | 8                   | 16(OEM提供)[^hgx_a100] | 32                    | 72                   |                  |
| 系统总算力     | 1 PFLOPS            | 5 PFLOPS               | 32 PFLOPS             | 180 PFLOPS           |                  |
| 系统HBM总容量  | 8 x 32GB = 0.256 TB | 16 x 80GB = 1.28 TB    | 32 x 144GB = 4.6 TB\| | 36 x 384GB = 13.8 TB |                  |

由此可见，超节点已成为驱动算力持续指数级增长的核心引擎。它的实现并非简单依赖于NVLink等某一单点技术的突破，而是一个将硬件、软件与应用范式深度融合的系统工程。为了系统性地拆解这一架构，本文将从硬件基石与软件生态两个层面展开详细论述。

## 超节点硬件系统

如前文所述，超节点通过系统级创新来支撑算力曲线的持续指数级增长。之所以要突破传统的"Scale-Out"扩展AI集群的范式，主要原因在于：

- **通信瓶颈**：PCIe与以太网的带宽增长难以匹配NVLink每两年带宽翻倍的快速增长。以H100为例，NVLink 4.0提供900GB/s的GPU间带宽，而PCIe 5.0 x16仅128GB/s，相差7倍。随着模型规模增长，这种差距会成为整个AI算力集群的核心瓶颈。
- **内存墙问题**：单节点GPU的显存容量有限，单纯HBM的迭代节奏难以满足大模型因模型规模和序列长度而快速增长的显存需求。GPT-4级别的模型需要数TB的显存，远超单节点8卡GPU的容量。
- **扩展效率递减**：在Scale-Out域，算力利用率随节点规模的增长而衰减。

超节点通过"Scale-Up"架构创新地解决了这些问题：在机柜级别构建高速无损互联域，将数十甚至数百个GPU通过NVLink/NVSwitch直接互联，形成一个逻辑上的"超级GPU"。这种架构转变不仅是技术参数的升级，更是AI基础设施设计理念的根本性变革。为了系统性地理解超节点硬件架构，我们需要从多芯片系统的互联层次出发，分析从微观到宏观的技术栈如何协同工作，最终支撑起大规模AI训练的需求。下图展示了从处理单元到集群的完整硬件构建蓝图，其中超节点最大的创新在于引入了"SuperPod"这一新层级，彻底改变了传统AI集群的互联拓扑。


<div style="display:flex;gap:1rem;flex-wrap:wrap;">
  <div style="flex:1;min-width:200px;">
```mermaid
block-beta
    columns 4
    PE0["PE"] space:2 PE1["PE"]
    space:4
    Die0["Die"] space:2 Die1["Die"]
    space:4
    Chip0["Chip"] space:2 Chip1["Chip"]
    space:4
    Node0["Node"] space:2 Node1["Node"]
    space:4
    Cluster0["Cluster"] space:2 Cluster1["Cluster"]

    PE0<-- "NOC" -->PE1
    Die0<-- "D2D" -->Die1
    Chip0<-- "C2C" -->Chip1
    Node0<-- "RDMA" -->Node1
    Cluster0<-- "DCN" -->Cluster1

    PE0-- "NOC" -->Die0
    PE1-- "NOC" -->Die1
    Die0-- "Chiplet" -->Chip0
    Die1-- "Chiplet" -->Chip1
    Chip0-- "PCIE" -->Node0
    Chip1-- "PCIE" -->Node1
    Node0-- "RDMA" -->Cluster0
    Node1-- "RDMA" -->Cluster1
```
  <center>
  常规AI算力集群
  </center>
  </div>
  <div style="flex:1;min-width:200px;">
```mermaid
block-beta
    columns 4
    PE0["PE"] space:2 PE1["PE"]
    space:4
    Die0["Die"] space:2 Die1["Die"]
    space:4
    Chip0["Chip"] space:2 Chip1["Chip"]
    space:4
    Node0["Node"] space:2 Node1["Node"]
    space:4
    Pod0["SuperPod"] space:2 Pod1["SuperPod"]
    space:4
    Cluster0["Cluster"] space:2 Cluster1["Cluster"]

    PE0<-- "NOC" -->PE1
    Die0<-- "D2D" -->Die1
    Chip0<-- "C2C" -->Chip1
    Node0<-- "C2C" -->Node1
    Pod0<-- "RDMA" -->Pod1
    Cluster0<-- "DCN" -->Cluster1

    PE0-- "NOC" -->Die0
    PE1-- "NOC" -->Die1
    Die0-- "Chiplet" -->Chip0
    Die1-- "Chiplet" -->Chip1
    Chip0-- "PCIE" -->Node0
    Chip1-- "PCIE" -->Node1
    Node0-- "C2C" -->Pod0
    Node1-- "C2C" -->Pod1
    Pod0-- "RDMA" -->Cluster0
    Pod1-- "RDMA" -->Cluster1
```
  <center>
  超节点AI算力集群
  </center>
  </div>
</div>

现代AI超算系统的硬件架构遵循自底向上的层次化设计原则，每一层都通过特定的互联技术将计算单元组织成更大规模的计算资源。这种层次化设计不仅体现了硬件工程的物理约束，也反映了系统架构师从微观到宏观的资源组织思维：

1.  **层级1 - 芯粒内部 (Die)**: 系统的最基本计算单元是 **处理单元 (PE)** ，例如GPU中的流式多处理器(SM)。在单个硅片(**Die**)上，众多的PE通过 **片上网络 (NoC)** 高效互联。
2.  **层级2 - 芯片 (Chip)**: 借助先进封装技术(Chiplet)，多个独立的 **芯粒 (Die)** 被封装在一起，构成一个完整的 **芯片 (Chip)** 。它们之间通过高速的 **Die-to-Die (D2D)** 接口（如NV-HBI, UCIe）通信，使其在逻辑上表现得像一个单片大芯片。
3.  **层级3 - 节点 (Node)**: 一个服务器 **节点 (Node)** 通常包含多个 **芯片 (Chip)**（如多块GPU）和CPU。节点内的GPU之间通过 **芯片间互联 (C2C)** 技术（如NVLink + NVSwitch）构建高速通信域，而GPU与CPU之间则主要通过 **PCIe总线** 连接。
4.  **层级4 - 集群 (Cluster)**: 多个 **节点 (Node)** 组合成一个 **集群 (Cluster)**。节点之间的通信（Scale-Out）依赖于 **数据中心网络** ，通常使用基于 **RDMA** 的InfiniBand或RoCE高速网络。

### 硬件互联技术

超节点的核心特征在于通过高速无损互联技术构建大规模计算域。其互联体系遵循从微观到宏观的层次化结构，从芯片内部的片上网络到集群级的数据中心网络，形成了完整的互联技术栈。典型的多芯片计算系统互联结构如下图所示：

![[芯片互联.drawio.svg]]

芯片（Chip）通常由不同的芯粒（Die）组成，比如CCD（Core Complex Die）和IOD（I/O Die）。其中前者通常包含CPU或GPU的主要计算单元，而后者则负责PCIe、内存控制器等I/O相关功能。通过CCD与IOD不同数量与规格的组合，可以制造出不同规格的芯片产品。在每个Die内部，通常使用片上网络（Network-on-Chip, NOC）来将处理单元（Processing Element, PE）组织起来，形成GPU上的计算单元，比如流式多处理器（Streaming Multiprocessor, SM）。而Die之间通过Die-to-Die（D2D）互联进行通信。芯片之间则通过Chip-to-Chip（C2C）互联进行通信。
不论是片上的NOC通信，还是D2D、C2C通信，都可以在逻辑上分为三层抽象：

- **物理层**：负责定义互联的物理形态、连接拓扑与信号的电气特性（频率、电压等）。
- **链路层**：负责定义数据如何进行高效可靠的传递，不负责理解数据的内容。
- **事务层**：负责定义事务处理逻辑，比如读写请求、内存一致性等。

为了方便理解，我们通过一张表格描绘当前NOC、D2D和C2C三层通信在物理、链路和事务三层之上有哪些选择：


|           | 物理层                                                                                                                                                                            | 链路层                                                                                                                                                                          | 事务层                                                                                                                                                                                                 |
|-----------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Die内通信 | 自定义的金属走线<br>使用数字信号                                                                                                                                                  | NoC网络<br>包含路由算法的定义<br>流控机制和数据包定义                                                                                                                           | 片上总线协议，比如<br>AMBA AXI和AMBA CHI                                                                                                                                                                |
| Die间通信 | - **BoW (Bunch of Wires)**：OCP定义的简化的die-to-die互连物理层协议<br>- **UCIe PHY**：UCIE的物理层规范<br>- 私有规范，比如AMD Infinity Fabric PHY, Intel AIB/Foveros PHY            | **UCIe D2D Adapter**: 负责链路训练、管理、CRC校验、重传机制<br>**私有实现**: AMD/Intel的私有链路管理逻辑                                                                           | **私有实现**: AMD Infinity Fabric Protocol (支持一致性)<br>**UCIe Protocol Layer**: 承载 **PCIe**, **CXL**, 和其他原生流协议(Streaming)                                                                |
| 片间通信  | - **CEI**: OIF制定的高速电气I/O规范，包含25.6G/56G/112G等多种规范<br>- **PCIe PHY**: 遵循或参考CEI<br>- **NVLink PHY**: NVIDIA私有SerDes实现<br>- **以太网PHY**: 如以太网光/电模块 | **PCIe Link Layer**: 流量控制、ACK/NAK、数据包排序<br>**CXL.io Link Layer**: 复用PCIe的链路层<br>**NVLink Link Layer**: NVIDIA私有链路管理和流控<br>**Ethernet MAC Layer / RoCE** | **PCIe Transaction Layer**: 内存读写(RW)、配置、消息<br>**CXL (.cache & .mem)**: 实现缓存一致性、内存扩展<br>**NVLink Protocol**: GPU间P2P内存访问、原子操作<br>**TCP/IP, RoCEv2**: 基于以太网的应用层协议 |

### 电互联关键技术基础

#### 基础物理单元：Lane与SerDes

当前高速数字信号通信普遍采用串行通信技术。其基础物理单元是 **Lane**，一个 Lane 通常由两对差分信号线组成：一对用于发送（Tx），一对用于接收（Rx），从而实现全双工通信。无论是 PCIe、NVLink 还是高速以太网，都是通过将多个 Lane 聚合（bonding）来获得更高总带宽。

芯片内部的数据通常是并行的（如 64 位或 128 位），为了在 Lane 上进行高速串行传输，需要一种专门的电路负责并行数据与串行信号之间的转换。这种电路被称为 **SerDes** (Serializer/Deserializer，串行器/解串器)。SerDes 将芯片内部的并行数据转换为高速串行信号发送出去，并在接收端将串行信号转换回并行数据。因此，单条 Lane 的传输速率直接受 SerDes 的能力和传输介质（线缆、PCB走线）的物理特性限制。

#### 标准化接口：OIF-CEI规范

为了确保不同厂商设备间的互联互通，光互联论坛（OIF）制定了通用电气接口（CEI）规范，对电气接口的物理形态、电压、频率以及信号调制方式等进行了标准化。例如，CEI-56G/112G/224G 等规范定义了单通道（per-lane）在 56Gbps、112Gbps、224Gbps 速率下的接口标准，其中广泛使用了 PAM4（4-Level Pulse Amplitude Modulation）等高级调制技术来提升数据速率。这些规范被 PCIe、CXL、NVLink 和以太网等主流互联协议广泛采纳或参考，作为其物理层设计的基础。

#### 主流协议的CEI实现

PCIe 和 NVLink 作为两种主流的片间互联协议，其核心创新在于链路层与事务层，而在物理层则高度依赖成熟的电气标准。它们的物理层设计与 CEI 规范密切相关，通常会选择某个版本的 CEI 规范作为其 SerDes 设计的电气基础，从而在确保信号可靠性的前提下，专注于上层协议的优化。例如：
*   **PCIe**: PCIe 5.0 的 32 GT/s 速率在电气特性上参考了 OIF CEI-28G 标准。而到了 PCIe 6.0，其 64 GT/s 的速率采用了 PAM4 调制技术，其电气特性与 OIF CEI-56G 系列标准的设计原则更为接近。
*   **NVLink**: NVIDIA H100 GPU 使用的第四代 NVLink，其单 Lane 单向速率为 100 Gbps（采用PAM4调制，波特率为50Gbaud），这与 OIF CEI-56G-PAM4 标准的电气特性一致。未来的 NVLink 版本预计将继续跟进更高速率的 CEI-112G/224G 标准。

通过这种方式，PCIe 和 NVLink 等协议可以复用业界成熟的电气标准，专注于其上层协议的创新。因此，OIF-CEI 规范的演进路线图，也成为了预判整个互联技术发展的关键风向标。目前CEI规范的主要节点如下：

| 规范系列     | 发布年份 (约) | 单通道速率 (Gbps) | 调制方式 | 典型应用/参考协议                                 |
|:-------------|:--------------|:------------------|:---------|:--------------------------------------------------|
| **CEI-28G**  | ~2011         | 28                | NRZ      | 100G 以太网 (4x25G), PCIe 4.0/5.0, InfiniBand EDR |
| **CEI-56G**  | ~2017         | 56                | PAM4     | 200G/400G 以太网, PCIe 6.0, NVLink 4.0 (H100)     |
| **CEI-112G** | ~2022         | 112               | PAM4     | 800G 以太网, CXL 3.0, 下一代 NVLink               |
| **CEI-224G** | -             | 224               | PAM4     | 1.6T/3.2T 以太网, 未来高速互联                    |

<small>
*注：NRZ (Non-Return-to-Zero) 每符号传输 1 bit 数据，PAM4 (Pulse Amplitude Modulation 4-level) 每符号传输 2 bit 数据，在相同波特率下可实现双倍数据速率。*
</small>

OIF-CEI规范通常5-6年一个版本，每次发布新版本时速率翻倍。但是上文所提到的时间为定稿时间，在定稿前行业内就会有较多的讨论和实现，因此不能完全以规范的时间来推测相关产品的面世时间。

### 电互联交换芯片的演进

交换芯片(Switch ASIC)是构建互联网络的核心，其交换容量和SerDes速率直接决定网络总带宽和端口密度。根据应用场景不同，主要分为数据中心网络交换芯片和GPU专用交换芯片两类。

#### 数据中心网络交换芯片

以Broadcom Tomahawk系列为代表的数据中心交换芯片，其演进与OIF-CEI规范紧密相关：

| 交换容量 (Tbps) | SerDes 速率 (每Lane) | CEI 代际对应 | 代表芯片 (发布年) | 可支持的典型 4-Lane 端口 (示例)                      |
|:----------------|:---------------------|:-------------|:------------------|:-----------------------------------------------------|
| 3.2T            | 25G NRZ              | CEI-28G      | Tomahawk (2014)   | 32 x 100G (4x25G)                                    |
| 6.4T            | 25G NRZ              | CEI-28G      | Tomahawk 2 (2016) | 64 x 100G (4x25G)                                    |
| 12.8T           | 50G PAM4             | CEI-56G      | Tomahawk 3 (2018) | 64 x 200G (4x50G)                                    |
| 25.6T           | 100G PAM4            | CEI-112G     | Tomahawk 4 (2020) | 64 x 400G (4x100G)                                   |
| 51.2T           | 100G PAM4            | CEI-112G     | Tomahawk 5 (2022) | 128 x 400G (4x100G)                                  |
| 102.4T (预测)   | 200G PAM4            | CEI-224G     | 下一代 (≈2025+)   | 128 x 800G (4x200G) 或 64 x 1.6T (8x200G, 非 4-Lane) |

<small>
*注：上表中的“4-Lane 端口”指由 4 个 SerDes 通道组成的逻辑端口，在常见的国产GPU厂商中比较常见此种配置。例如，一个 100G 端口由 4x25G 组成，一个 400G 端口可由 4x100G 组成。随着 SerDes 速率翻倍，单芯片的总交换容量和端口速率也随之翻倍，这是网络技术演进的核心驱动力。*
</small>

Broadcom的高端交换芯片通常两年一代，交换容量翻倍。而从芯片产品面世到广泛被交换机使用，大约也需要1-2年时间。此外，从Broadcom芯片规格的发展也能看出，行业领先厂商对CEI标准的实现和落地通常会先于规范的正式定稿。

#### GPU专用交换芯片：NVSwitch

NVSwitch 负责在单机或机柜域内构建 GPU 全互连（all-to-all / non-blocking）通信结构，其能力随 NVLink 代际一起提升。提升路径主要有两种：增加每 GPU 可用的 NVLink 数量（link fan-out）与提高单条 NVLink 的速率。下表采用 “GB/s (双向)” 口径（NVIDIA 官方常用聚合带宽，等于 2 × 单方向带宽；1 GB/s ≈ 8 Gb/s）。

| 代际  | GPU 架构  | 发布（约） | NVLink 版本 | 每 Link Lane 数 | 每 Lane 速率 (Gbps) | 每 Link 双向带宽 (GB/s) | 每 GPU Link 数 | 每 GPU 聚合双向带宽 (GB/s) | 典型单机/底板 GPU 数 | 可扩展最大 NVLink 域（官方宣称） | 备注                                                 |
|:------|:----------|:---------|:------------|:----------------|:--------------------|:------------------------|:---------------|:---------------------------|:---------------------|:-------------------------------|:-----------------------------------------------------|
| 第1代 | Volta     | 2018     | 2.0         | 8               | 25                  | 50                      | 6              | 300                        | 16                   | 16                             | 首次通过 NVSwitch 实现 16 GPU 全互连，每 Link 8 Lanes |
| 第2代 | Ampere    | 2020     | 3.0         | 4               | 50                  | 50                      | 12             | 600                        | 8                    | 16                             | Lane 数减半但速率翻倍，带宽不变但功耗优化             |
| 第3代 | Hopper    | 2022     | 4.0         | 4               | 100                 | 100                     | 18             | 1800                       | 8                    | 256**                          | Lane 速率翻倍至 100Gbps，每 Link 带宽翻倍             |
| 第4代 | Blackwell | 2025     | 5.0         | 4               | 200                 | 200                     | 18             | 3600                       | 72                   | 576***                         | Lane 速率再次翻倍至 200Gbps                          |

<small>
*注：NVIDIA NVSwitch缺乏官方公开的详细规格数据，因此部分数据为根据产品介绍推测。如有不准确之处，欢迎反馈。*
</small>

### 互联拓扑

互联拓扑定义了计算节点（或GPU）间的物理连接方式与逻辑结构，它直接决定了整个系统的通信性能，包括带宽、延迟、扩展性和成本。在超节点架构中，选择合适的拓扑是构建高效、无阻塞通信域的基石。当前主流技术路径为电子分组交换（Electronic Packet Switching，EPS），而光学电路交换（Optical Circuit Switching，OCS）作为前沿方向也备受关注。我们首先以最为常见的 **Full Mesh拓扑** 为例来分析GPU的互联拓扑，以及互联拓扑有哪些关键性质。

**Full Mesh（全互联）** ，或称全连接（All-to-All），是理论上最理想的通信拓扑结构。网络中的每一个节点都与其他所有节点建立直接的点对点连接。

```mermaid
block-beta
    columns 7
    space:2 N0 space N1 space:2
    space:7
    N7 space:5 N2
    space:7
    N6 space:5 N3
    space:7
    space:2 N5 space N4

    N0 --- N1
    N0 --- N2
    N0 --- N3
    N0 --- N4
    N0 --- N5
    N0 --- N6
    N0 --- N7
    N1 --- N2
    N1 --- N3
    N1 --- N4
    N1 --- N5
    N1 --- N6
    N1 --- N7
    N2 --- N3
    N2 --- N4
    N2 --- N5
    N2 --- N6
    N2 --- N7
    N3 --- N4
    N3 --- N5
    N3 --- N6
    N3 --- N7
    N4 --- N5
    N4 --- N6
    N4 --- N7
    N5 --- N6
    N5 --- N7
    N6 --- N7
```

为了能够定量比较不同的互联拓扑，需要引入一些关键指标：

- **网络直径（Network Diameter）**：指网络中任意两个节点间的最短路径长度，刻画了最坏情况下的通信延迟。Full Mesh拓扑中任意两个节点直接连接，因此 **网络直径为1** 。在Fat-Tree拓扑中，任意两个节点间的通信最多只需经过“上行-下行”三跳（Leaf-Spine-Leaf），因此 **网络直径为3** 。
- **二分带宽（Bisection Bandwidth）**：指当网络被切成两半时，连接这两半部分的总通信能力。它反映了网络在最坏通信场景下的最大数据传输能力。在Full Mesh拓扑中，一半网络有 \(N/2\) 个节点，每个节点有 $N/2$ 条链路连接到另一半网络，因此Full Mesh拓扑的二分带宽为 $\dfrac{N}{2} \times \dfrac{N}{2} \times B = \dfrac{N^2}{4} B$ 。在Fat-Tree拓扑下，一半网络有 \(N/2\) 个节点，每个节点都能与另一半网络全速率通信，因此Fat-Tree拓扑的二分带宽为 $\dfrac{N}{2} B$。
- **径向扩展度（Radix Scalability）**：指在给定交换芯片 radix 条件下的最大无阻塞集群规模 $N_{max}$ 。它衡量了在给定交换芯片端口数（R_switch）和终端设备接口数（R_dev）的条件下，一个拓扑理论上能构建的最大无阻塞集群规模。Full Mesh拓扑下，互联规模 $N_{max} = R_{dev} + 1$ ，Fat-Tree拓扑下 $N_{max} = R_{switch}^2 / 2 / R_{dev}$ 。

接下来介绍构建Scale-Up域用的拓扑结构。

**Fat-Tree（胖树）** 拓扑是当前构建大规模、高性能计算和AI集群最主流的架构。它是一种分层的网络结构，其核心设计思想是：从网络边缘（终端节点）向核心（根方向）上行时，链路带宽逐级增加，确保任意两个节点间的通信都拥有充足的带宽资源，从而实现或逼近“无阻塞”通信。典型的胖树网络由“叶交换机”（Leaf Switches）和“脊交换机”（Spine Switches）组成。计算节点直接连接到叶交换机，每个叶交换机又与所有脊交换机相连。这种结构保证了任意两个不同叶交换机下的节点通信最多只需经过“上行-下行”三跳（Leaf-Spine-Leaf）。Fat-Tree拓扑具备如下特点：
  * **高带宽与无阻塞**：通过精心设计上行与下行链路的带宽比例（收敛比），胖树网络可以为All-to-All等复杂通信模式提供接近线速的聚合带宽。
  * **良好的扩展性**：可以通过增加Spine交换机或增加网络层级来平滑地扩展集群规模。
  * **高容错性**：任意一条链路或交换机故障，流量可以被重新路由到其他路径，不会导致单点失效。

NVIDIA的DGX SuperPOD架构本质上就是一个精心设计的两级Fat-Tree网络。
*   **第一级**：在单个节点内部，多颗NVSwitch芯片构建了一个单级的、逻辑上完全无阻塞的全互联网络（Full Mesh），将域内所有GPU全互联起来。
*   **第二级**： 第一级的NVSwitch再通过第二级的NVSwitch进行互联，形成一个32卡的Scale-Up通信域。

![alt text](imgs/superpod/NVL32.png){width=68%}

**Dragonfly拓扑**[^dragonfly] 是一种为超大规模计算设计的、旨在降低网络直径和成本的拓扑结构。它将路由器（交换机）和与之相连的计算节点组织成“组”（Group）。组内，路由器之间实现全互联（All-to-All）。组间，通过长距离的“全局链路”进行稀疏连接。Dragonfly拓扑具备如下特点：
  * **低网络直径**：任意两个节点间的通信路径非常短，通常最多只需一跳组内路由和一跳全局路由。
  * **成本效益**：相比于同等规模的全连接胖树，Dragonfly所需的全局链路和交换机端口更少，成本更低。

  ![alt text](imgs/superpod/dragonfly.png){width=68%}

Dragonfly的挑战在于，全局链路相对稀疏，就像一个城市的主干道有限。如果路由策略不佳，所有流量都涌向少数几条主干道，就会造成严重的拥堵。因此，它必须依赖智能的、能感知全局负载的路由算法，动态地为数据包规划‘行车路线’，才能发挥其低延迟和成本优势。

**Torus拓扑**[^torus] 是一种规则的格状拓扑，在多维（如2D、3D、6D）网格的每个维度上都带有“环绕式”连接。每个节点都与其在各个维度上的“邻居”直接相连。Torus拓扑具备如下特点：
  * **优异的局部性**：非常适合具有邻近通信模式的科学计算应用（如气象模拟、流体力学），因为相邻节点间通信延迟极低。
  * **二分带宽较低**：将其切成两半时，横跨切面的链路数量相对较少，这意味着其全局All-to-All通信性能不如胖树。
  * **扩展性受限**：高维Torus布线复杂，扩展成本高。

**SlimFly拓扑** [^slimfly]：作为Dragonfly的演进，SlimFly是一种在给定交换机端口数下，能够以更少的网络直径和接近最优的二分带宽连接更多节点的拓扑结构。它在理论上被证明是构建超大规模网络最高效的拓扑之一，但其不规则的连接方式对物理布线和路由算法设计提出了极高挑战，目前更多处于学术研究和前沿探索阶段。

对于以All-to-All和All-Reduce为主导通信模式的AI大模型训练而言，胖树拓扑因其优越的全局带宽特性与确定的网络直径而成为事实上的标准选择。但另一方面，Fat-Tree所能达到的互联规模也受限于交换机容量。在超节点继续演进的过程中，对互联拓扑的探索也尤为重要：

| 拓扑      | 径向扩展度                                             | 网络直径               | 二分带宽                |
|-----------|--------------------------------------------------------|------------------------|-------------------------|
| Full Mesh | $R_{dev} + 1$                                          | 1                      | $\dfrac{N^2}{4} B$      |
| Fat-Tree  | $\dfrac{R_{switch}^2}{2 R_{dev}}$                      | 3                      | $\dfrac{N}{2} B$        |
| Dragonfly | $\dfrac{R_{switch}^4}{81 R_{dev}}$                     | $\le 3$                | $\approx \dfrac{N}{2}B$ |
| Torus     | 无上界                                                 | $D \cdot \dfrac{k}{2}$ |                         |
| Slim Fly  | $\dfrac{32}{243} \times \dfrac{R_{switch}^3}{R_{dev}}$ | 2–3                    | 设计为接近满二分带宽    |

## 软件系统

软件系统架构的根本决定因素是内存模型。传统操作系统内核围绕CPU访存权限进行设计，通过虚拟内存管理、页表机制和TLB等组件构建了现代计算的基础。同样，PCIe引入的MMIO（Memory Mapped I/O）机制决定了内核驱动的编程范式，设备寄存器被映射到统一的地址空间，通过内存访问指令进行控制。

超节点的出现从根本上改变了这一范式。通过NVLink/NVSwitch等高速互联技术构建的HBD（High Bandwidth Domain）通信域，使得远程GPU显存能够以接近本地访问的性能被直接访问。为了实现高效通信，HBD域上正在构建一个能 **绕过（Bypass）CPU和操作系统内核** 的、由GPU主导的通信架构。在这个新架构下，访存的控制权发生了转移：
1.  **从CPU中心到GPU中心**：跨GPU的内存访问不再需要CPU作为中介，而是由GPU的MMU（内存管理单元）直接发起，由硬件（如NVSwitch）进行路由。
2.  **从内核态仲裁到用户态直通**：上层应用（如CUDA Kernel）通过统一虚拟地址（UVA）操作远程数据，其地址翻译和路由完全在硬件层面透明完成，内核仅在初始设置和资源管理时介入。

为了更好地理解超节点带来的这一变革，接下来从GPU访存体系入手来分析软件系统的演进路径。

### 现代GPU访存体系

NVIDIA超节点在软件系统架构上与其 **单个节点内部** 的GPU访存体系一脉相承，均围绕 **UVA（Unified Virtual Addressing）** 技术构建。与传统CPU类似，现代GPU也配备了完整的内存管理单元（MMU），负责虚拟地址到物理地址的转换。UVA技术的引入，将GPU显存、CPU内存等不同物理内存统一映射到单一的虚拟地址空间中。上一章我们讨论了NVLink和NVSwitch等物理互联技术，它们构建了数据传输的高速公路。软件层面利用这条高速公路的核心便是统一虚拟寻址（UVA）与对等内存访问（Peer Memory Access）：

1. **发现与连接建立**：系统中的GPU通过物理总线（如NVLink或PCIe）互相发现，建立对等连接并分配唯一的Peer ID。

```mermaid
graph LR
    A[GPU-A] ---|NVLINK/PCIe| B[GPU-B]
    A --> C[发现 Peer GPU]
    B --> D[建立 Peer 连接]
    C --> E[分配 Peer ID]
    D --> E
```
2. **Aperture选择与地址映射** ：驱动程序分配UVA地址，并根据连接类型选择不同的Aperture通道：
   - **本地显存 (VID Memory)** ：同一GPU内的内存访问
   - **对等内存 (Peer Memory)** ：通过NVLink直接访问远程GPU显存
   - **系统内存 (SYS Memory)** ：通过PCIe访问CPU主存
   - **Fabric内存** ：在NVSwitch环境下的专用地址空间
3. **硬件透明的远程访存** ：当CUDA Kernel访问虚拟地址时，GPU MMU自动完成地址翻译和路由。硬件MMU通常提供4-5级页表，支持4K-128K页大小。考虑到MMU页表中的地址可能并非全部是内存地址，也包含部分IO地址。因此GPU MMU的表项也会标识是否支持缓存一致性。

以下是GPU上访问UVA地址的流程：

```mermaid
sequenceDiagram
    participant App as 应用程序<br>(CUDA Kernel)
    participant LocalMMU as 本地GPU MMU
    participant Interconnect as NVLink/NVSwitch
    participant RemoteGPU as 远程GPU

    App->>LocalMMU: 1. 访问虚拟地址 0x1000
    activate LocalMMU
    LocalMMU-->>LocalMMU: 2. 查页表, 发现PTE指向Peer
    LocalMMU->>Interconnect: 3. 发起硬件路由请求
    deactivate LocalMMU

    activate Interconnect
    Interconnect->>RemoteGPU: 4. 转发内存访问请求
    deactivate Interconnect

    activate RemoteGPU
    RemoteGPU-->>RemoteGPU: 5. 访问本地物理显存
    Note right of RemoteGPU: 数据被读取/写入
    RemoteGPU-->>App: 6. (经由硬件)返回结果
    deactivate RemoteGPU
```
UVA在节点内实现的编程透明性与硬件高效性，为构建更大规模、跨节点的统一地址空间奠定了范式基础。随着硬件演进，软件侧的地址模型与编程范式也在逐步向CPU成熟的体系靠拢。总体趋势是：CPU与OS内核正从“关键数据路径”中解放出来，转而扮演“控制平面”的角色，通过配置虚拟地址与MMU来管理访存与通信，而非直接参与每一次操作。

### 超节点访存体系

传统的UVA和PCIe P2P机制的边界仅限于单个PCIe根联合体（Root Complex），无法原生支持跨物理服务器节点的直接访存。以下是PCIe总线上节点内部的访存体系：

![mmio](imgs/superpod/MMIO.drawio.svg)

1. 主存、设备的控制寄存器和设备内置存储（比如显存）都会通过PCIE RC映射到一个统一的MMIO地址空间（Memory Mapped I/O）；
2. 在内核态，设备驱动通过MMIO地址操作设备寄存器，从而实现对设备的初始化、控制与中断处理；
3. 在用户态，可以直接将设备的存储映射到用户态地址空间，从而实现用户态对设备的直接读写，让数据路径by pass内核。GPU Direct RDMA技术即将部分显存映射到用户态，再交给RDMA网卡去访问。RDMA网卡的doorbell寄存器（用于通知网卡有工作需要处理）也可以通过这种映射交给GPU去访问，从而实现IBGDA（GPU异步RDMA数据发送）；

在传统的基于PC的AI算力服务器上，上述软件技术架构已成为事实标准。然而，在超节点中，上述访存体系面临本质缺陷：PCIe通信域无法纳管其他节点的设备，因此也无法提供跨节点的统一访存地址空间。

超节点通过NVSwitch Fabric等技术，将“节点内”的P2P模型扩展至整个机柜乃至多个机柜。其关键在于引入了一个由 **Fabric Manager** 管理的[^fabricmanager] **47-bit的 全局物理地址空间** ：
1.  **全局地址分配**：Fabric Manager为HBD域内的每个GPU分配一个唯一的、在全局范围内无冲突的物理地址（PA）范围。
2.  **VA到全局PA的映射**：当一个GPU需要访问远程GPU时，其驱动程序不再映射到对端的PCIe BAR地址，而是将用户态的虚拟地址（VA）通过页表（PTE）映射到这个全局物理地址（PA）。
3.  **硬件路由**：当GPU的MMU翻译VA并得到这个全局PA时，它会生成一个带有目标GPU ID的硬件请求。该请求被发送到NVSwitch网络，由交换芯片根据地址和ID，像路由器转发IP包一样，精准地将读写操作路由到目标GPU的物理显存上。

### 软件编程模型

超节点的硬件发展催生了软件编程模型的演进。当前主流的SPMD范式正面临挑战，而以PGAS为代表的新范式则为解决这些挑战提供了清晰的路径。

#### 主流范式及其瓶颈：SPMD 与 BSP

当前几乎所有大规模AI训练都构建于 **SPMD (Single Program, Multiple Data)** 模型之上。所有GPU运行相同程序，处理不同数据分片，并通过`NCCL`等库进行高效的集合通信。

其成功源于其遵循了 **BSP (Bulk Synchronous Parallel, 块同步并行)** 的计算范式。BSP将并行计算清晰地分为三个阶段：1) 本地计算，2) 全局通信，3) **同步屏障 (Barrier)**。所有GPU必须在屏障处等待，直到最慢的那个GPU完成后，才能一起进入下一阶段。

![alt text](imgs/superpod/bsp.png)

这种严格的同步正是其最大的弱点。在大规模集群中，“慢节点” (Straggler) 问题几乎无法避免，而BSP模型会放大其负面影响。一个节点的延迟会拖慢整个集群。慢节点产生的原因多种多样：
- **硬件层面**：微小的时钟频率差异、功耗墙限制、网络瞬时拥塞。
- **软件层面**：操作系统后台进程的干扰 (Jitter)。
- **数据层面**：这在现代AI负载中愈发关键。例如，在**MoE模型**中，不同的数据（Token）会被路由到不同的专家，导致专家负载不均；在**强化学习**或**长序列推理**中，输出序列长度不定，导致各GPU计算时间不同。

在这些场景下，BSP的同步屏障会导致大量GPU处于空闲等待状态，极大地降低了计算效率。正是为了解决这一根本性矛盾，业界开始转向更为灵活的编程模型。

#### PGAS 与混合编程

**PGAS (Partitioned Global Address Space)** 是解决上述瓶颈的未来方向之一。它通过**单边通信 (One-Sided Communication)**，从根本上改变了数据交换的模式。

| 特性         | SPMD + 集合通信 (NCCL)                                  | PGAS + 单边通信 (NVSHMEM)                                |
|:-------------|:--------------------------------------------------------|:---------------------------------------------------------|
| **通信模型** | **双边 (Two-Sided)**：`Send`与`Recv`需配对，依赖集体同步。 | **单边 (One-Sided)**：`Put`/`Get`无需对方协同，可异步执行。 |
| **编程抽象** | **通信是集体操作**：`AllReduce(data)`                    | **通信如内存访问**：`put(&dest, &src, size)`              |
| **适用负载** | **静态、均匀** (如稠密模型训练)                          | **动态、非均匀** (如MoE, 推理)                            |

在PGAS模型中，整个分布式系统由众多PE（Processing Elements）组成。为了实现SHMEM语义，对每个PE的地址空间进行如下划分：

![alt text](imgs/superpod/pgas.png){width=68%}

1. 每个PE都有自己独立的地址空间；这能够映射到不同节点的不同进程中去；
2. 进程的内存地址空间分为两部分：
  1. Private地址空间，这部分为进程私有，可以被进程随意使用；
  2. Symmetric地址空间，这部分为远程可访问的地址空间，所有进程保持一致；

进程可以通过PE的rank与Symmetric Address来读写其他PE的内存，从而实现单边通信。这种单边通信能较好解决“慢节点”问题：它将 **同步的“通信握手”** 变成了 **异步的“内存操作”** 。在双边通信中，一个“快节点”的`Send`操作必须等待“慢节点”准备好`Recv`，从而被强制阻塞。而在单边通信中，“快节点”只需知道目标地址，就可以通过`Put`操作直接将数据写入“慢节点”的内存，然后立即返回执行后续任务。数据写入后，“慢节点”何时去处理它，并不会反过来阻塞“快节点”的进度。这种异步、解耦的机制打破了BSP模型的全局同步枷锁，从而极大地提升了系统在非均匀负载下的计算效率。


## TODO（待阐述的观点、待补充的内容和待修复的问题）

1. 黄氏定理，算力10年增长1000倍，包含了低精度方面的进步；而超节点，每两年fp16算力增长6倍，10年可达到7000倍，考虑FP8和FP4这些低精度算力的话，算力增长可以达到10000倍以上；




## 参考文献

[^gb200]: [NVIDIA DGX GB200](https://resources.nvidia.com/en-us-dgx-systems/dgx-superpod-gb200-datasheet)
[^gh200]: [NVIDIA GH200 Grace Hopper
Superchip](https://resources.nvidia.com/en-us-data-center-overview-mc/en-us-data-center-overview/grace-hopper-superchip-datasheet-partner)
[^hgx_a100]: [NVIDIA HGX A100](https://www.nvidia.com/content/dam/en-zz/Solutions/Data-Center/HGX/a100-80gb-hgx-a100-datasheet-us-nvidia-1485640-r6-web.pdf)
[^nvhbi]: [Inside NVIDIA Blackwell Ultra: The Chip Powering the AI Factory Era](https://developer.nvidia.com/blog/inside-nvidia-blackwell-ultra-the-chip-powering-the-ai-factory-era/)
[^nvl32]: [NVIDIA GH200 Grace Hopper Superchip Architecture](https://resources.nvidia.com/en-us-grace-cpu/nvidia-grace-hopper?ncid=no-ncid)
[^dragonfly]: [Technology-Driven, Highly-Scalable Dragonfly Topology](https://ieeexplore.ieee.org/abstract/document/4556717)
[^torus]: [Understanding Torus Network Performance through Simulations](http://datasys.cs.iit.edu/reports/2014_GCASR14_paper-torus.pdf)
[^slimfly]: [Slim Fly: A Cost Effective Low-Diameter Network Topology](https://arxiv.org/pdf/1912.08968)
[^fabricmanager]: [Nvidia Fabric Manager](https://github.com/NVIDIA/open-gpu-kernel-modules/blob/2b436058a616676ec888ef3814d1db6b2220f2eb/kernel-open/nvidia-uvm/uvm_gpu.h#L1292)
[^nvshmem]: [Magnum IO GPUDirect, NCCL, NVSHMEM, and GDA-KI on Grace Hopper and Hopper systems](https://static.rainfocus.com/nvidia/gtcs24/sess/1693876934119001DqDe/FinalPresPDF/S61368_1710778532525001A5Z4.pdf)
[^pathways]: [Pathways: Asynchronous Distributed Dataflow for ML](https://arxiv.org/abs/2203.12533)